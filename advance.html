<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advance — Royal Sherwani (Backup)</title>
<style>
  :root{--accent1:#007bff;--accent2:#00c6ff;--danger:#dc3545}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:linear-gradient(180deg,#f3f7ff,#ffffff);color:#222}
  header{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff;padding:14px 16px;display:flex;align-items:center;justify-content:center;position:relative;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
  .back{position:absolute;left:14px;color:#fff;text-decoration:none;font-weight:700}
  .title{font-weight:800;font-size:18px}
  .logout{position:absolute;right:12px;background:var(--danger);border:none;color:#fff;padding:8px 12px;border-radius:12px;cursor:pointer;font-weight:700}
  .container{max-width:1100px;margin:18px auto;padding:14px}
  .muted{color:#556677;font-size:14px}
  .center{display:flex;justify-content:center;margin:26px 0}
  .btn-backup{background:linear-gradient(90deg,#6a11cb,#2575fc);color:#fff;padding:16px 26px;border-radius:14px;border:none;font-weight:800;font-size:16px;cursor:pointer;box-shadow:0 12px 28px rgba(40,100,200,0.12)}
  .status{max-width:980px;margin:14px auto;padding:12px;background:#fff;border-radius:10px;box-shadow:0 10px 30px rgba(10,20,40,0.04)}
  .small{font-size:13px;color:#666}
  .hidden{display:none!important}
  progress{width:100%}
  .counts{display:flex;gap:12px;justify-content:center;margin-top:12px;flex-wrap:wrap}
  .count-card{background:#fff;padding:10px 12px;border-radius:10px;box-shadow:0 6px 18px rgba(10,20,40,0.04);min-width:120px;text-align:center}
  a.download-link{display:inline-block;margin-top:8px;color:var(--accent1);font-weight:700}
  .note{max-width:980px;margin:12px auto;text-align:center;color:#445; font-size:14px}
  .modal{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:200}
  .modal.show{display:flex}
  .modal-box{background:#fff;border-radius:12px;padding:18px;width:92%;max-width:420px;box-shadow:0 18px 60px rgba(4,10,30,0.2)}
  .input{width:100%;padding:10px;border-radius:8px;border:1px solid #e6e9ef;margin-top:8px}
  .secret-note{font-size:13px;color:#666;margin-top:8px;text-align:center}
  .small-muted{font-size:12px;color:#888;margin-top:6px;text-align:center}
  code{background:#f6f8fb;padding:2px 6px;border-radius:4px}
</style>

<!-- JSZip -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <header>
    <a href="index.html" class="back">⬅ Back</a>
    <div class="title">Royal Sherwani — Advance (Backup)</div>
    <button id="logoutBtn" class="logout">Logout</button>
  </header>

  <main class="container">
    <div id="intro" class="muted" style="text-align:center">
      This Advance page is protected by a secret code. Enter the code to continue and use the Backup feature (IndexedDB → ZIP).
    </div>

    <div id="mainActions" class="hidden">
      <div class="center">
        <button id="backupBtn" class="btn-backup">Create Backup ZIP</button>
      </div>

      <div id="statusBox" class="status hidden" aria-live="polite">
        <div id="statusText" class="small">Preparing...</div>
        <div style="margin-top:10px"><progress id="zipProgress" value="0" max="100"></progress></div>
        <div id="percent" style="text-align:right;margin-top:6px">0%</div>
        <div id="counts" class="counts" style="margin-top:12px"></div>
        <div id="downloadArea" style="text-align:center;margin-top:12px"></div>
        <div style="margin-top:8px" class="small">ZIP will include <code>backup.json</code> and an <code>images/</code> folder (images renamed by bill_no).</div>
      </div>

      <div class="note">Backup filename will be: <code>userid-dd-mm-yyyy-hh-mm-ss.zip</code></div>
    </div>
  </main>

  <!-- Secret code modal -->
  <div id="secretModal" class="modal show" role="dialog" aria-modal="true" aria-labelledby="secretTitle">
    <div class="modal-box">
      <h3 id="secretTitle" style="margin:0">Enter Secret Code</h3>
      <div class="secret-note">Advance section is protected. Enter the numeric code to continue.</div>
      <input id="secretInput" class="input" type="number" placeholder="Enter numeric code" />
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:center">
        <button id="secretSubmit" class="btn-backup" style="padding:10px 18px;font-size:14px">Open</button>
      </div>
      <div id="secretMsg" style="color:#a00;text-align:center;margin-top:8px"></div>
    </div>
  </div>

<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js";

  // ----- CONFIG -----
  const SECRET_CODE = '2128722';
  const SUPABASE_URL = "https://zrbetimapyxqzzxyxbrg.supabase.co";
  const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpyYmV0aW1hcHl4cXp6eHl4YnJnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY3OTgwODYsImV4cCI6MjA3MjM3NDA4Nn0.XzBz0JUuJS9EUbuoWEt7P75jl8dfl3q2KfJAFXnTq4E";
  const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

  // ----- DOM -----
  const secretModal = document.getElementById('secretModal');
  const secretInput = document.getElementById('secretInput');
  const secretSubmit = document.getElementById('secretSubmit');
  const secretMsg = document.getElementById('secretMsg');
  const mainActions = document.getElementById('mainActions');
  const backupBtn = document.getElementById('backupBtn');
  const statusBox = document.getElementById('statusBox');
  const statusText = document.getElementById('statusText');
  const zipProgress = document.getElementById('zipProgress');
  const percentEl = document.getElementById('percent');
  const countsDiv = document.getElementById('counts');
  const downloadArea = document.getElementById('downloadArea');
  const logoutBtn = document.getElementById('logoutBtn');

  let currentUser = null;

  // try restore saved user session if present
  try {
    const saved = localStorage.getItem('supabaseUser');
    if (saved) currentUser = JSON.parse(saved);
  } catch(e){ /* ignore */ }

  // try to get supabase user if not present locally
  (async function tryGetUser(){
    if (!currentUser) {
      try {
        const { data } = await supabase.auth.getUser();
        if (data && data.user) currentUser = data.user;
      } catch(e){ /* ignore */ }
    }
  })();

  // helpers
  const pad = n => String(n).padStart(2,'0');
  function nowParts(){
    const d = new Date();
    return { dd: pad(d.getDate()), mm: pad(d.getMonth()+1), yyyy: d.getFullYear(), hh: pad(d.getHours()), min: pad(d.getMinutes()), ss: pad(d.getSeconds()) };
  }
  function sanitizeFileName(s){
    return String(s||'').replace(/[@\s\/\\:*?"<>|]+/g,'_').replace(/,+/g,'_').replace(/\s+/g,'_');
  }
  function parseImagesField(val){
    if (!val) return [];
    if (Array.isArray(val)) return val;
    try { const p = JSON.parse(val); return Array.isArray(p) ? p : []; } catch(e){ return []; }
  }
  function dataURLtoBlob(dataurl) {
    const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
    const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
    while(n--) u8arr[n] = bstr.charCodeAt(n);
    return new Blob([u8arr], {type:mime});
  }
  function createCountCard(title, n){
    const div = document.createElement('div'); div.className = 'count-card';
    div.innerHTML = `<div style="font-weight:700">${n}</div><div class="small">${title}</div>`;
    return div;
  }

  // ----- IndexedDB helpers (store images using full path as key, e.g. 'images/<userFolder>/<file>') -----
  function idbOpen(dbName = 'royal_backup_db', storeName = 'images') {
    return new Promise((res, rej) => {
      const req = indexedDB.open(dbName, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'key' });
        }
      };
      req.onsuccess = () => res({ db: req.result, storeName });
      req.onerror = () => rej(req.error || new Error('IndexedDB open failed'));
    });
  }

  function idbPut(dbHandle, key, blob) {
    return new Promise((res, rej) => {
      const tx = dbHandle.db.transaction(dbHandle.storeName, 'readwrite');
      const store = tx.objectStore(dbHandle.storeName);
      const r = store.put({ key, blob });
      r.onsuccess = () => res(true);
      r.onerror = () => rej(r.error || new Error('idb put failed'));
    });
  }

  function idbGet(dbHandle, key) {
    return new Promise((res, rej) => {
      const tx = dbHandle.db.transaction(dbHandle.storeName, 'readonly');
      const store = tx.objectStore(dbHandle.storeName);
      const r = store.get(key);
      r.onsuccess = () => {
        if (r.result) res(r.result.blob); else res(null);
      };
      r.onerror = () => rej(r.error || new Error('idb get failed'));
    });
  }

  function idbClear(dbHandle) {
    return new Promise((res, rej) => {
      const tx = dbHandle.db.transaction(dbHandle.storeName, 'readwrite');
      const store = tx.objectStore(dbHandle.storeName);
      const r = store.clear();
      r.onsuccess = () => res(true);
      r.onerror = () => rej(r.error || new Error('idb clear failed'));
    });
  }

  // ----- offline viewer templates are NOT included in ZIP on purpose (user requested). -----

  // ----- Secret code handling -----
  function showMainActions() {
    secretModal.classList.remove('show');
    secretModal.classList.add('hidden');
    mainActions.classList.remove('hidden');
  }

  secretSubmit.addEventListener('click', onSecretSubmit);
  secretInput.addEventListener('keydown', (e)=> { if (e.key === 'Enter') onSecretSubmit(); });

  function onSecretSubmit(){
    const v = (secretInput.value || '').toString().trim();
    if (!v) { secretMsg.textContent = 'Please enter the code'; return; }
    if (v === SECRET_CODE) {
      secretMsg.textContent = '';
      showMainActions();
    } else {
      secretMsg.textContent = 'Incorrect code';
    }
  }

  // ----- Backup flow (fetch bills -> fetch images -> store in IDB as images/<userFolder>/... -> build ZIP with backup.json + images/) -----
  backupBtn.addEventListener('click', async () => {
    downloadArea.innerHTML = '';
    countsDiv.innerHTML = '';

    if (!currentUser) {
      alert('No user session found. Please login first or ensure supabaseUser is saved in localStorage.');
      return;
    }

    statusBox.classList.remove('hidden');
    statusText.textContent = 'Fetching bills from Supabase...';
    zipProgress.value = 0; percentEl.textContent = '0%';

    // open IndexedDB
    let dbHandle;
    try {
      dbHandle = await idbOpen('royal_backup_db', 'images');
    } catch (e) {
      console.warn('IndexedDB open failed', e);
      statusText.textContent = 'IndexedDB unavailable — cannot proceed.';
      return;
    }

    try {
      const { data: bills, error } = await supabase.from('bills').select('*').eq('user_id', currentUser.id);
      if (error) throw error;
      const billsList = bills || [];

      const metadata = { exported_by: currentUser.email || currentUser.id, exported_user_id: currentUser.id, exported_at: new Date().toISOString(), bills: [] };

      statusText.textContent = `Found ${billsList.length} bills — fetching & storing images into IndexedDB...`;

      const userFolder = sanitizeFileName(String(currentUser.email || currentUser.id));
      let totalImagesAttempted = 0;
      let totalImagesStored = 0;

      // We'll collect images to add to zip: map path -> blob
      const imagesToAdd = new Map();

      for (let i = 0; i < billsList.length; i++) {
        const b = billsList[i];
        const item = {
          id: b.id,
          bill_no: b.bill_no,
          delivery_date: b.delivery_date || null,
          delivered_date: b.delivered_date || null,
          amount: b.amount || null,
          method: b.method || null,
          status: b.status || null,
          notes: b.notes || null,
          main_images: parseImagesField(b.main_images),
          measurement_images: parseImagesField(b.measurement_images)
        };

        if (item.status && String(item.status).toLowerCase() === 'delivered') {
          item.delivered_copy = 'Bill No: ' + item.bill_no + '\nAmount: ' + (item.amount || '') + '\nPayment: ' + (item.method || '') + '\nDelivered Date: ' + (item.delivered_date || item.delivery_date || '');
        }

        // process main images
        const storedMain = [];
        for (let mi = 0; mi < item.main_images.length; mi++) {
          const src = item.main_images[mi];
          totalImagesAttempted++;
          let entry = src; // by default fallback to original
          // create filename
          const baseName = `${sanitizeFileName(String(item.bill_no))}_main_${mi}`;
          // extension default jpg unless we detect blob type
          try {
            if (typeof src === 'string' && src.startsWith('http')) {
              statusText.textContent = `Fetching image ${totalImagesAttempted}...`;
              const res = await fetch(src, { mode: 'cors' });
              if (!res.ok) throw new Error('fetch failed');
              const blob = await res.blob();
              const ext = (blob.type && blob.type.split('/')[1]) ? blob.type.split('/')[1] : 'jpg';
              const path = `images/${userFolder}/${baseName}.${ext}`;
              // store in IDB under EXACT path key (so restore reads same key)
              await idbPut(dbHandle, path, blob);
              imagesToAdd.set(path, blob);
              entry = path;
              totalImagesStored++;
            } else if (typeof src === 'string' && src.startsWith('data:')) {
              const blob = dataURLtoBlob(src);
              const ext = (blob.type && blob.type.split('/')[1]) ? blob.type.split('/')[1] : 'png';
              const path = `images/${userFolder}/${baseName}.${ext}`;
              await idbPut(dbHandle, path, blob);
              imagesToAdd.set(path, blob);
              entry = path;
              totalImagesStored++;
            } else {
              // not a http or data URL — keep as-is (maybe already local path or missing)
              entry = src;
            }
          } catch (err) {
            console.warn('Could not fetch/store main image', src, err);
            // fallback: keep original URL
            entry = src;
          }
          storedMain.push(entry);
          zipProgress.value = Math.min(98, Math.round((totalImagesAttempted / Math.max(1, billsList.length * 2)) * 100));
          percentEl.textContent = zipProgress.value + '%';
        }
        item.main_images = storedMain;

        // process measurement images
        const storedMeas = [];
        for (let mi = 0; mi < item.measurement_images.length; mi++) {
          const src = item.measurement_images[mi];
          totalImagesAttempted++;
          let entry = src;
          const baseName = `${sanitizeFileName(String(item.bill_no))}_meas_${mi}`;
          try {
            if (typeof src === 'string' && src.startsWith('http')) {
              statusText.textContent = `Fetching image ${totalImagesAttempted}...`;
              const res = await fetch(src, { mode: 'cors' });
              if (!res.ok) throw new Error('fetch failed');
              const blob = await res.blob();
              const ext = (blob.type && blob.type.split('/')[1]) ? blob.type.split('/')[1] : 'jpg';
              const path = `images/${userFolder}/${baseName}.${ext}`;
              await idbPut(dbHandle, path, blob);
              imagesToAdd.set(path, blob);
              entry = path;
              totalImagesStored++;
            } else if (typeof src === 'string' && src.startsWith('data:')) {
              const blob = dataURLtoBlob(src);
              const ext = (blob.type && blob.type.split('/')[1]) ? blob.type.split('/')[1] : 'png';
              const path = `images/${userFolder}/${baseName}.${ext}`;
              await idbPut(dbHandle, path, blob);
              imagesToAdd.set(path, blob);
              entry = path;
              totalImagesStored++;
            } else {
              entry = src;
            }
          } catch (err) {
            console.warn('Could not fetch/store measurement image', src, err);
            entry = src;
          }
          storedMeas.push(entry);
          zipProgress.value = Math.min(98, Math.round((totalImagesAttempted / Math.max(1, billsList.length * 2)) * 100));
          percentEl.textContent = zipProgress.value + '%';
        }
        item.measurement_images = storedMeas;

        metadata.bills.push(item);
      } // end bills loop

      statusText.textContent = `Preparing ZIP — ${totalImagesStored} images stored locally. Building backup.json...`;

      // Build ZIP: add images from imagesToAdd and backup.json
      const zip = new JSZip();
      zip.file('README.txt', `Royal Sherwani backup (offline)\nExported by: ${metadata.exported_by}\nExport time: ${metadata.exported_at}\n\nStructure:\n - backup.json\n - images/...`);
      // add images (imagesToAdd map)
      let added = 0;
      for (const [path, blob] of imagesToAdd.entries()) {
        zip.file(path, blob);
        added++;
      }

      // add backup.json
      zip.file('backup.json', JSON.stringify(metadata, null, 2));

      statusText.textContent = `Compressing ZIP (images added: ${added})...`;
      const blob = await zip.generateAsync({ type: 'blob' }, (meta) => {
        zipProgress.value = Math.round(meta.percent);
        percentEl.textContent = zipProgress.value + '%';
      });

      // create filename
      const t = nowParts();
      const safeUser = sanitizeFileName(String(currentUser.email || currentUser.id));
      const filename = `${safeUser}-${t.dd}-${t.mm}-${t.yyyy}-${t.hh}-${t.min}-${t.ss}.zip`;

      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.className = 'download-link';
      a.textContent = `Download backup: ${filename}`;
      downloadArea.innerHTML = '';
      downloadArea.appendChild(a);
      a.click();

      statusText.textContent = `Backup ready — ${filename}`;
      zipProgress.value = 100;
      percentEl.textContent = '100%';

      // show counts
      const booked = metadata.bills.filter(b => (b.status||'').toLowerCase() === 'booked').length;
      const ready = metadata.bills.filter(b => (b.status||'').toLowerCase() === 'ready').length;
      const delivered = metadata.bills.filter(b => (b.status||'').toLowerCase() === 'delivered').length;
      countsDiv.appendChild(createCountCard('Booked', booked));
      countsDiv.appendChild(createCountCard('Ready', ready));
      countsDiv.appendChild(createCountCard('Delivered', delivered));

      // optional: clear idb or keep (we'll keep it for now so restore/preview can use it)
      // If you want to clear to avoid storing images locally after ZIP is created, uncomment:
      // try { await idbClear(dbHandle); } catch(e){ console.warn('idb clear failed', e); }

    } catch (err) {
      console.error(err);
      statusText.textContent = 'Backup failed: ' + (err && err.message ? err.message : String(err));
      zipProgress.value = 0; percentEl.textContent = '0%';
    }
  });

  logoutBtn.addEventListener('click', async () => {
    localStorage.removeItem('supabaseUser');
    try { await supabase.auth.signOut(); } catch(e){}
    window.location.href = 'index.html';
  });

  // expose for debugging
  window._advanceBackup = { supabase };

</script>
</body>
</html>